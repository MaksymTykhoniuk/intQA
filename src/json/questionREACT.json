[
  {
    "question": "Для чого потрібен Virtual DOM в React? ",
    "answer": "Віртуальний DOM - це концепція програмування, в якій «віртуальне» представлення інтерфейсу користувача зберігається в пам'яті та синхронізується з «справжнім» DOM за допомогою бібліотеки, такої як ReactDOM. Ця техніка дозволяє покращити продуктивність на клієнтській стороні, уникаючи прямої роботи з DOM шляхом роботи з легким JavaScript-об'єктом, що імітує DOM-дерево."
  },
  {
    "question": "Різниця між virtual DOM та shadow DOM? ",
    "answer": "Virtual DOM - повне представлення реального DOM-дерева у вигляді JavaScript-об'єкта. Його найважливішою особливістю є групування змін та виконання одиночного рендерингу замість безлічі дрібних.Shadow DOM - це нативна реалізація в браузері, яка дозволяє створити свій, ізольований, DOM. Всередині Shadow DOM створюється окремий /піддокумент/, до якого можна застосовувати свої стилі, екрановані від впливу зовнішнього середовища."
  },
  {
    "question": "В чому різниця між state та props? ",
    "answer": "props - передається в компонент ззовні. state - внутрішній стан компонента."
  },
  {
    "question": "В чому різниця між класовим та функціональним компонентом? ",
    "answer": "У класових компонентів є state, а у функціональних його немає. Але стан для функціонального компонента можна додати за допомогою хука useState. У класових компонентів є методи життєвого циклу, а у функціональних його немає. Але деякі методи життєвого циклу для функціонального компонента можна реалізувати за допомогою хука useEffect."
  },
  {
    "question": "Які є методи життєвого циклу в React? ",
    "answer": "В React є 3 фази: монтування, оновлення та розмонтування. У кожній із цих фаз є свої методи життєвого циклу. Монтування: Ці методи викликають у такому порядку, коли екземпляр компонента створюється і додається в DOM:- constructor() - static getDerivedStateFromProps() - render() - componentDidMount() Оновлення:Оновлення може бути викликане змінами у властивостях або стані. Ці методи викликається у такому порядку, коли компонент повторно відмальовується:- static getDerivedStateFromProps() - shouldComponentUpdate() - render() - getSnapshotBeforeUpdate() - componentDidUpdate() Розмонтування: Цей метод викликається коли компонент видаляється з DOM:- componentWillUnmount()Обробка помилок:Цей метод викликається при виникненні помилки під час рендеру, у методі життєвого циклу або в конструкторі будь-якого дочірнього компонента:- static getDerivedStateFromError()- componentDidCatch()"
  },
  {
    "question": "Як обновити state в класовому компоненті? ",
    "answer": "Для того, щоб оновити стан у класовому компоненті, можна використовувати метод setState. Цей метод є асинхронним і React може згрупувати кілька викликів setState() в одне оновлення для поліпшення продуктивності. Метод setState може приймати функцію для того, щоб оновити стейт на основі вже наявного state. Виклик методу setState завжди призводить до оновлення компонента."
  },
  {
    "question": " Чому setState - це асинхронна функція?",
    "answer": "Це потрібно для того, щоб React зміг згрупувати кілька викликів setState() в одне оновлення для покращення продуктивності. Виклик setState призводить до оновлення компонента, тому setState зробили асинхронною, щоб /дочекатися/ поки всі компоненти викличуть setState() у своїх обробниках подій, перш ніж почати повторний рендер. Це позбавляє непотрібних повторних рендерів."
  },
  {
    "question": "Що потрібно зробити, щоб компонент обновився? ",
    "answer": "Для того, щоб оновився компонент потрібно: - щоб змінився state, шляхом виклику метода setState. - щоб змінилися props. - викликати метод forceUpdate."
  },
  {
    "question": "Як попередити/відмінити лишнє оновлення компоненту? ",
    "answer": "Існує кілька способів: - реалізувати метод життєвого циклу shouldComponentUpdate, який скасовує рендер, якщо з нього повернути значення false. - успадкуватися від PureComponent при створенні класового компонента."
  },
  {
    "question": "Що таке PureComponent і в чому його особливість? ",
    "answer": "В більшості випадків PureComponent можна використовувати замість написання власного shouldComponentUpdate. Але він робить лише поверхневе порівняння."
  },
  {
    "question": "Для чого потрібен key? ",
    "answer": "key - це спеціальний рядковий атрибут, який потрібно вказувати під час створення списку елементів. Ключі допомагають React визначати, які елементи були змінені, додані чи видалені. Їх необхідно вказувати, щоб React міг зіставляти елементи масиву з плином часу."
  },
  {
    "question": "Для чого потрібен Fragment? ",
    "answer": "React компонент завжди повинен повертати тільки один елемент. Але іноді бувають завдання коли треба повернути кілька елементів. Фрагменти дозволяють формувати список дочірніх елементів, не створюючи зайвих вузлів в DOM."
  },
  {
    "question": "Для чого потрібні портали? ",
    "answer": "Портали дозволяють рендерити дочірні елементи в DOM-вузол, що знаходиться поза DOM-ієрархією батьківського компонента."
  },
  {
    "question": "Що таке refs?",
    "answer": "Рефи дають можливість отримати доступ до DOM-вузлів або React-елементів, створених у рендер-методі. Також рефи можуть зберігати в собі будь-яку іншу інформацію, окрім DOM-вузла."
  },
  {
    "question": " Що таке context? Скільки context? може бути в проекті?",
    "answer": "У React-додатку дані передаються зверху вниз за допомогою props. Однак, подібний спосіб використання може бути надто громіздким для деяких типів props, які необхідно передавати до багатьох компонентів у додатку. Контекст надає спосіб ділитися такими даними між компонентами без необхідності явно передавати пропси через кожен рівень дерева."
  },

  {
    "question": "Для чого потрібні render props? ",
    "answer": "Render props - це можливість компонентів React розділяти код між собою за допомогою пропа, значенням якого є функція. Компонент із рендер-пропом бере функцію, яка повертає React-елемент, і викликає її замість реалізації власного рендеру."
  },
  {
    "question": " Для чого потрібні HOCs?",
    "answer": "Компонент вищого порядку - це функція, яка приймає компонент та повертає новий компонент. Це потрібно для того, щоб винести певну бізнес-логіку в одне місце та знову використовувати її шляхом композиції компонентів."
  },
  {
    "question": "Як реалізувати компонент запобіжника (Error Boundary)? ",
    "answer": "Запобіжники — це компоненти React, які виловлюють помилки JavaScript в будь-якому місці дерев їх дочірніх компонентів, зберігають їх у журналі помилок і виводять запасний UI замість дерева компонентів, що звалилося. Класовий компонент є запобіжником, якщо він реалізує хоча б один із методів життєвого циклу: static getDerivedStateFromError() або componentDidCatch()."
  },
  {
    "question": "Які можливості відкривають хуки? Які хуки ви знаєте? ",
    "answer": "Хуки дозволяють використовувати стан та інші можливості React без написання класів. Хуки дозволяють повторно використовувати логіку стану, не зачіпаючи дерева компонентів."
  },
  {
    "question": "Які правила використання хуків? ",
    "answer": "Хуки — звичайні JavaScript-функції, але є два правила, яких потрібно дотримуватися. Не викликайте хуки всередині циклів, умовних операторів чи вкладених функцій. Натомість завжди використовуйте хуки тільки всередині React-функцій або всередині власного хука, до повернення будь-якого значення з них. Також, при створенні власного хука, його ім'я має починатися з «use»."
  },
  {
    "question": "Для чого потрібен useEffect? ",
    "answer": "Хук useEffect дає можливість виконувати побічні ефекти у функціональному компоненті. - Якщо передати функцію в useEffect, вона буде викликатися після кожного рендеру та оновлення.- Якщо передати функцію та її залежність в useEffect, вона буде викликатися після рендеру і щоразу, коли її залежність змінюється. - Якщо передати функцію в useEffect, яка повертає іншу функцію, ця функція буде викликана перед розмонтуванням компонента."
  },
  {
    "question": "Чим відрізняється useEffect від useLayoutEffect? ",
    "answer": "- useEffect викликається після рендеру та оновлення компонента. - useLayoutEffect викликається синхронно перед рендером та оновленням компонента. useLayoutEffect запускається у тій же фазі, що і componentDidMount та componentDidUpdate."
  },
  {
    "question": "Що таке лiнива ініціалізація стану в useState і useReducer? ",
    "answer": "Коли початковий стан є результатом виклику якоїсь функції, його можна ініціалізувати /ліниво/ для того, щоб при кожному оновленні компонента ця функція не викликалася. Для цього в useState або useReducer потрібно передати функцію, яка поверне початковий стан, і буде викликана лише один раз, під час першого рендеру."
  },
  {
    "question": "Чим useRef відрізняється від createRef? ",
    "answer": "Різниця в тому, що коли потрібно створити ref всередині функціонального компонента, використовуючи createRef, він буде створюватися щоразу, коли оновлюється компонент. Використовуючи useRef, він створюється 1 раз під час монтування."
  },
  {
    "question": "Для чого потрібні useMemo та useCallback? ",
    "answer": "- Хук useMemo буде повторно обчислювати мемоізоване значення лише тоді, коли значення якоїсь із залежностей змінилося. Ця оптимізація допомагає уникнути дорогих обчислень під час кожного рендеру. - Хук useCallback поверне мемоізовану версію колбека, який змінюється лише тоді, коли змінюються значення однієї із залежностей. Це корисно під час передачі колбеків оптимізованим дочірнім компонентам, які покладаються на рівність посилань для запобігання непотрібним рендерам."
  },
  {
    "question": " Для чого потрібен redux?",
    "answer": "Redux - це бібліотека для керування станом програми. У звичайному додатку React компоненти мають свій state і можуть передавати його в якості props для дочірніх компонентів. У React-redux програмах є один глобальний state, на який підписуються компоненти, яким потрібно з нього читати дані."
  },
  {
    "question": " Поясніть redux data flow?",
    "answer": "Життєвий цикл даних у будь-якій Redux-програмі включає 5 кроків: 1 - викликається dispatch(action). Action - це простий javascript-об'єкт, який описує що трапилося. 2 - action потрапляє в middleware, і якщо це необхідно, запускає якийсь сайд-ефект. 3 - redux-стор викликає функцію-редюсер із двома аргументами: поточне дерево стану (state) та екшен (action). 4 - головний редюсер може комбінувати результат роботи кількох редюсерів у єдине дерево стану програми. 5 - redux-стор зберігає повне дерево стану, яке повертає головний редюсер."
  },
  {
    "question": " Що таке redux middleware?",
    "answer": "Redux middleware надають сторонню точку розширення між відправкою екшену і моментом, коли цей екшен досягає редюсера. Redux middleware часто використовують для логування, повідомлення про помилки, спілкування з асинхронним API, роутингу тощо."
  },
  {
    "question": "Де потрібно робити side effects в redux? ",
    "answer": "Redux натхненний функціональним програмуванням і з коробки виконання побічних ефектів у ньому немає місця. Зокрема функції редюсера завжди повинні бути чистими функціями типу (state, action) => newState. Однак, мідлвари Redux-а дозволяють перехоплювати екшени та додавати до них складну поведінку, що включає побічні ефекти."
  },
  {
    "question": " Що таке next() функція в redux middleware?",
    "answer": "Виклик next (action) в middleware призведе до того, що дія буде передана наступному middleware, а потім в редюсер. Це потрібно, щоб дотримуватися ланцюжка викликів middleware."
  },
  {
    "question": " Для чого потрібні redux селектори?",
    "answer": "Селектори — це гетери для стану redux. Як і гетери, селектори інкапсулюють структуру стану та можуть використовуватися повторно. Селектори також можуть обчислювати похідні властивості."
  },
  {
    "question": "Чим відрізняється action від action creator? ",
    "answer": "action - це об'єкт, який описує, що сталося. action creator - це функція, яка може приймати якісь параметри та повертає action."
  }
]
