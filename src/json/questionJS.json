[
  {
    "question": " Які типи даних присутні в JavaScript?",
    "answer": "Існує 8 типів даних. 7 примітивних та 1 складний тип даних. Примітивні типи: number, string, boolean, symbol, bigInt, null, undefined. Складний тип - object. Він використовується для колекцій даних та для оголошення більш складних сутностей. Також він передається за посиланням, а прості типи даних за значенням."
  },
  {
    "question": "Що таке NaN? ",
    "answer": "NaN (not a number) - це значення, що отримується в результаті виконання числової операції над не числовим значенням. Його тип даних number. NaN не дорівнює самому собі. Перевірку на NaN можна зробити за допомогою Number.isNaN"
  },
  {
    "question": "В чому різниця між null та undefined? ",
    "answer": "undefined (невизначений) являє собою значення за замовчуванням: 1 - змінної, яку оголосили без ініціалізації; 2 - функції, яка нічого не повертає явно; 3 - неіснуючої властивості об'єкта. null - це значення «відсутності значення». Присвоюється змінній явно."
  },
  {
    "question": "Чим відрізняється строга рівність від не строгої (=== і ==)? ",
    "answer": "Строга рівність порівнює значення за типом даних та значенням. Нестроге приводить значення до одного типу, а потім ці значення порівнює."
  },
  {
    "question": "оператори !, &&, || ",
    "answer": "Оператор &&, || приводить усі операнди до буля і повертає значення одного з них.Логічне && затинається на брехні та повертає те, на чому застрягло, або останній операнд. Логічне || затинається на правді й повертає те, на чому зациклилося, або останній операнд. Усі оператори, які ми розглядали до цього, були бінарними - такими, що містять два операнди, лівий і правий. Логічне /HE/ це унарний оператор - виконує операцію над одним операндом праворуч. Оператор ! приводить операнд до буля, якщо необхідно, а потім робить інверсію - замінює його на протилежний true -> false або false -> true."
  },
  {
    "question": "Що таке use strict і для чого він потрібен?",
    "answer": "Нова можливість у специфікації ECMAScript 5, яка дає змогу переводити скрипт у режим повної відповідності сучасному стандарту. Це запобігає певним помилкам, як-от використання небезпечних і застарілих конструкцій."
  },
  {
    "question": " Чому результатом порівняння двох схожих обєктів буде false?",
    "answer": "Тому що об'єкти - це типи даних, що передаються за посиланням. 2 однакові на вигляд об'єкта мають різні посилання, і тому операція порівняння повертатиме false."
  },
  {
    "question": "Як перевірити ідентичність 2х обєктів? ",
    "answer": "1 - використовувати JSON.stringify для приведення об'єктів у рядок та порівняти їх вже як 2 рядки. Такий підхід має обмеження. Якщо в об'єкті будуть методи або symbol - JSON.stringify не зможе конвертувати їх у рядок. 2 - написати або використати з бібліотеки функцію deepEqual, яка буде проходити циклом по ключах двох об'єктів і перевірятиме значення цих ключів. Функція має працювати рекурсивно."
  },
  {
    "question": "Як зробити копію обєкта? ",
    "answer": "Існує поняття глибокого та поверхневого копіювання. Глибоке - це копіювання об'єкта та всіх його рівнів вкладеності. Поверхневе - це копіювання лише першого рівня вкладеності, а для решти копіюється посилання. Способи поверхневого копіювання: 1 - використовувати spread оператор (...) 2 - використовувати Object.assign() Способи глибокого копіювання: 1 - використовувати JSON.stringify - JSON.parse для конвертування об'єкта в рядок і потім назад. Має обмеження щодо копіювання методів та symbols 2 - написати або використати з бібліотеки функцію deepClone яка буде рекурсивно проходитиме за ключами об'єкта та копіюватиме їх у новий об'єкт."
  },
  {
    "question": "Чим відрізняються змінні var, let и const? ",
    "answer": "var - змінну можна ініціалізувати після оголошення, можна змінювати, має функціональну область видимості, має hoisting. Зараз майже не використовують під час написання нового коду. let - змінну можна ініціалізувати після оголошення, можна змінювати, має блокову область видимості, не має hoisting. const - змінну обов'язково потрібно ініціалізувати під час оголошення, не можна змінювати, має блокову область видимості, не має hoisting."
  },
  {
    "question": "Як дізнатись, чи являються дані масивом? ",
    "answer": "Для цього можна використати метод Array.isArray."
  },
  {
    "question": "Які перебираючі методи масивів ви знаєте? ",
    "answer": "Є такі методи: - forEach - для перебору масиву. - filter - для фільтрації масиву. - every/some - для перевірки масиву. - map - для трансформації масиву в масив. - reduce/reduceRight - для проходу по масиву з обчисленням значення. - sort - сортує масив."
  },
  {
    "question": "Як обєднати масиви? ",
    "answer": "1 - Можна використовувати метод concat(). 2 - Можна використовувати spread оператор та об'єднати ці масиви в один загальний масив."
  },
  {
    "question": "Як дізнатись, чи знаходиться елемент в масиві? ",
    "answer": "1 - Використати метод includes, який повертає true якщо елемент знаходиться у масиві. 2 - Використати метод indexOf, який повертає індекс знайденого елемента в масиві або -1 якщо елемента в масиві немає. 3 - також можна використати метод find, який повертає знайдений елемент, або повертає undefined."
  },
  {
    "question": " Чи можна використовувати цикл for in для масивів? Які недоліки такого методу?",
    "answer": ""
  },

  {
    "question": "Що таке підняття (hoisting)? ",
    "answer": "Це механізм у JavaScript, в якому змінні та оголошення функцій, пересуваються вгору своєї області видимості перед тим, як код буде виконаний. Піднімаються змінні типу var та function declaration."
  },
  {
    "question": "Яким буде значення змінної var при зверненні до неї до її обявлення? ",
    "answer": "Значенням змінної буде undefined."
  },
  {
    "question": "Що буде, якщо звернутись до змінних let/const до початку їх обявлення? ",
    "answer": "Буде помилка типу ReferenceError. Змінної ще не існує"
  },
  {
    "question": "Що таке область видимості (Scope)? Яка вона буває? ",
    "answer": "Це місце, де (або звідки) ми маємо доступ до змінних або функцій. JS має 4 типи областей видимості: глобальна, функціональна, блокова (ES6) та область видимості eval."
  },
  {
    "question": "Різниця між Function Declaration та Function Expression? ",
    "answer": "Function Expression створюється, коли виконання доходить до нього, а потім вже може використовуватися. Function Declaration можна використовувати у всьому скрипті (або блоці коду, якщо функцію оголошено в блоці)."
  },
  {
    "question": "Що таке callback функції? ",
    "answer": ""
  },
  {
    "question": " Чим стрілкова функція відрізняється від звичайних функцій?",
    "answer": "1 - Стрілочна функція не має власного this. Вона бере його за місцем створення. У звичайній функції this визначається під час виклику. 2 - Стрілочна функція не має arguments. 3 - Стрілочна функція не має prototype. 4 - Стрілочна функція має короткий синтаксис неявного повернення значення."
  },
  {
    "question": " Чи є аналог arguments для стрілкових функцій?",
    "answer": "Аналога немає. Але можна використовувати rest оператор (...) для того, щоб зібрати всі параметри з якими викликана функція в масив."
  },
  {
    "question": "Як визвати функцію із затримкою в 5 секунд? ",
    "answer": "setTimeout(() => alert('💥'), 5000);"
  },
  {
    "question": "Що таке лексичне оточення (Lexical Environment)? ",
    "answer": "Це властивості внутрішнього об'єкта функції, які створюються під час її виклику. Туди записуються аргументи, функції та змінні. Також там знаходиться посилання на зовнішнє лексичне оточення."
  },
  {
    "question": "Що являється глобальним лексичним оточенням? ",
    "answer": "У несуворому режимі це window. У суворому - undefined."
  },
  {
    "question": "Що таке замикання (Closures)?  ",
    "answer": "Це здатність функції під час створення запам'ятовувати посилання на змінні, функції та параметри, що знаходяться в поточному лексичному оточенні, а також у лексичному оточенні батьківської функції й так до глобального лексичного оточення. Замикання передбачає саме зовнішні змінні, а не саму функцію."
  },
  {
    "question": "Для чого використовують замикання? ",
    "answer": "1 - Часто для створення приватних змінних та функцій (інкапсуляція).2 - Для збереження проміжних параметрів виклику функції (каррування)."
  },
  {
    "question": "Що таке IIFE? ",
    "answer": "Immediately Invoked Function Expression - це функція, яка викликається або виконується одразу після створення або оголошення."
  },
  {
    "question": "Основні принципи ООП? ",
    "answer": "Поняття класу та об’єкту є основою об’єктно-орієнтованого програмування (ООП). Програма створюється як деяка сукупність об’єктів, які взаємодіють між собою. ООП базується на трьох основних принципах:інкапсуляція, наслідування та поліморфізм. Інкапсуляція — це об’єднання в межах класу певних даних і методів для роботи з ними.Наслідування — це можливість створення нового класу (нащадка) на базі існуючого (базового).Поліморфізм — це різна поведінка методу в різних класах. Методи з однаковим ім’ям, описані в різних класах, можуть мати різну реалізацію."
  },
  {
    "question": " Що таке this?",
    "answer": "Це посилання на контекст виклику функції. Контекстом є об'єкт, який в цей момент виконує або викликає функцію. Для стрілочної функції — це об'єкт у якому вона створена, а у звичайній функції — яким вона викликана. Контекстом може бути: 1 - this в об'єкті — вказує на сам об'єкт 2 - this в класі — вказує на екземпляр класу 3 - глобальним контекстом є window (або undefined в режимі use strict)"
  },
  {
    "question": "Як можна змінити контекст виклику функції? ",
    "answer": "Є 3 методи: call, apply, bind. call та apply викликають функцію із заданим контекстом. bind повертає нову функцію із вже назавжди прив'язаним контекстом."
  },
  {
    "question": "Чи можна змінити контекст функції, яку повернув метод bind? ",
    "answer": "Ні, bind прив'язує контекст назавжди."
  },
  {
    "question": "Чи можна змінити контекст стрілкової функції? ",
    "answer": "Ні. Стрілочна функція не має методів call, apply, bind і своїх аналогів. Також вона використовує контекст у якому її створили, а не контекст у якому її викликали."
  },
  {
    "question": "Що таке прототип обєкту? ",
    "answer": "Це шаблон об'єкта. Він використовується як запасний варіант для властивостей та методів, що існують у цьому об'єкті. Це також один зі способів обміну властивостями та функціональністю між об'єктами. Це основна концепція прототипного наслідування в JS."
  },
  {
    "question": " Як працює прототипне наслідування в JS?",
    "answer": "Коли ми хочемо прочитати властивість з об'єкта, а вона відсутня - JavaScript спробує прочитати його з прототипу об'єкта. Якщо властивості немає в прототипі, JavaScript намагатиметься його прочитати з прототипу прототипу, і т.д. доки властивість не буде знайдено або ланцюжок прототипів не закінчиться. У такому разі JavaScript поверне undefined."
  },
  {
    "question": "Як створити обєкт в якому не буде прототипу? ",
    "answer": "Використати Object.create(). Цей метод приймає першим аргументом об'єкт, який буде прототипом об'єкта, який він поверне. Якщо ми викличемо Object.create() з аргументом null, буде створено об'єкт без прототипу."
  },
  {
    "question": "Як перевірити, чи являється властивість обєкта його особистою властивістю або це властивість прототипу? ",
    "answer": "Можна використовувати метод hasOwnProperty, який повертає true або false, в залежності від того, чи містить об'єкт зазначену властивість, як власну властивість, чи ні."
  },
  {
    "question": "Як заборонити змінювати об'єкт? ",
    "answer": "1 - Є метод Object.freeze(), який /заморожує/ об'єкт від змін. Цей метод працює тільки в один бік. Скасувати дію цього методу вже неможливо. 2 - Є метод Object.seal(), який забороняє додавати нові властивості, але вже наявні властивості можна змінювати.3 - Також є метод Object.preventExtensions(), який забороняє додавати нові властивості в об'єкт."
  },
  {
    "question": " Чим відрізняється функція конструктор і клас?",
    "answer": "Клас — це синтаксичний цукор над функцією конструктора. Під час створення екземпляра класу, методи описані в ньому потрапляють у прототип, а методи описані всередині функції конструктора потраплять у сам екземпляр. Для того, щоб методи, описані всередині функції конструктора, потрапили в прототип, їх потрібно окремо туди додати."
  },
  {
    "question": "Що потрібно зробити, щоб метод класа потрапив до його екземпляру? ",
    "answer": "Такий метод слід описати всередині конструктора."
  },
  {
    "question": "Що таке LocalStorage ? ",
    "answer": "Дозволяє зберігати дані без закінчення терміну дії у форматі пар ключ:значення на комп'ютері користувача та читати їх під час повторного відвідування сторінки. Локальне і сховище сесії - це частина браузера, тому вони доступні як властивості об'єкта window, мають однаковий набір властивостей і методів і розрізняються тільки поведінкою."
  },
  {
    "question": "Що таке SessionStorage? ",
    "answer": "Сховище сеансів (sessionStorage) схоже на локальне, воно також унікальне для кожного веб-додатка, але час життя збережених даних обмежений сесією вкладки браузера. Щойно користувач закриває вкладку або браузер, дані очищаються. На практиці сховище сеансів використовується значно рідше."
  },
  {
    "question": "Що таке Promise? ",
    "answer": "Це об'єкт, який використовують для відкладених та асинхронних обчислень. Promise має 3 стани: - очікування (pending): початковий стан, не виконаний та не відхилений. - виконано (fulfilled): операцію завершено успішно. - відхилено (rejected): операцію завершено з помилкою."
  },
  {
    "question": "Для чого потрібен метод Promise.all ",
    "answer": "Очікує виконання всіх промісів або відхилення будь-якого з них. Повертає проміс, який виконається після виконання всіх промісів. У випадку, якщо будь-який з промісів буде відхилено, Promise.all також буде відхилено. У нього є аналог Promise.allSetled, який виконується як тільки всі отримані проміси завершені (виконані або відхилені), що містить масив результатів виконання отриманих промісів."
  },
  {
    "question": "Для чого потрібен метод Promise.race? ",
    "answer": "Очікує виконання або відхилення будь-якого з отриманих промісів. Повертає проміс, який буде виконано або відхилено з результатом виконання першого виконаного або відхиленого промісу."
  },
  {
    "question": " Що таке async/await і для чого він потрібен?",
    "answer": "Ключове слово async робить створену функцію асинхронною. Функція async може містити вираз await, який призупиняє виконання функції async і чекає відповіді від переданого Promise, потім відновлює виконання функції async і повертає отримане значення."
  },
  {
    "question": "Як обробити помилки в async/await? ",
    "answer": "1 - Для цього можна використовувати конструкцію try...catch() 2 - викликати метод .catch() після виклику функції."
  },
  {
    "question": "Що таке event loop? ",
    "answer": "Це механізм, який відповідає за виконання коду, збору та обробки подій та виконання підзадач із черги.У концепції event loop є кілька блоків: - call stack - відповідає за створення контексту виконання функції. Кожна функція, що викликається, потрапляє в call stack. - heap - це велика не структурована область пам'яті, в якій зберігаються оголошені змінні, функції тощо. - third party API - API, які надає оточення. Наприклад, метод fetch, який надається браузером. - queue - список завдань, що підлягають обробці. Кожне завдання асоціюється з деякою функцією, яка буде викликана, щоб опрацювати це завдання."
  },
  {
    "question": "Що таке CRUD?  ",
    "answer": "Для взаємодії з ресурсами бекенда використовується чотири операції: створення (create), читання (read), оновлення (update) і видалення (delete). Для кожної з них визначено стандартний HTTP-метод."
  }
]
